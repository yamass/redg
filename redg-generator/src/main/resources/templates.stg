// This is the template for the RedG main class that contains all the addX and existingX methods
mainClass(package, prefix, tables, enableVisualizationSupport) ::= <<
/*
 * This file was generated by RedG.
 * https://yamass.github.io/redg
 * DO NOT EDIT MANUALLY!
 * Re-run the code generation to reflect database changes.
 */
package <package>;

import de.yamass.redg.runtime.*;
<if(enableVisualizationSupport)>
import de.yamass.redg.models.*;
import de.yamass.redg.runtime.dummy.DummyFactory;
import de.yamass.redg.runtime.visualization.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.lang.reflect.Method;
import java.util.*;
import java.util.stream.Collectors;
<endif>
import java.util.function.Supplier;

/**
 * \<p>This is the RedG main class. Use it to specify your test data and then insert them into the database.\</p>
 * \<p>Use this class to customize the RedG runtime options. Use can use the following methods:\</p>
 * \<ul>
 *   \<li>{@link AbstractRedG#setDefaultValueStrategy(DefaultValueStrategy)} to set the default value strategy\<li>
 *   \<li>{@link AbstractRedG#setDummyFactory(DummyFactory)} to set the dummy factory\</li>
 *   \<li>{@link AbstractRedG#setPreparedStatementParameterSetter(PreparedStatementParameterSetter)} to set the prepared statement parameter setter\</li>
 *   \<li>{@link AbstractRedG#setInsertValuesFormatter(InsertValuesFormatter)} to set the insert values formatter\</li>
 * \</ul>
 */
public class <prefix>RedG extends AbstractRedG {

    private Object entitySelfReference;

    <tables:tableBuilder()>
    <tables:tableBuilderSupplier()>
    <tables:tableBuilderExisting()>
    <tables:tableBuilderDummy()>

    public \<T> Supplier\<T> entitySelfReference() {
        return () -> (T) this.entitySelfReference;
    }

    public static java.util.List\<de.yamass.redg.models.TableModel> getAllTableModels() {
        return java.util.Arrays.asList(
            <tables:{it | <it.className>.getTableModel()};separator=",\n">
        );
    }

    <if(enableVisualizationSupport)>
    public String getVisualizationJson() {
        return VisualizationUtil.getVisualizationJson(this.getEntities(), this.getDummyFactory()::isDummy);
    }
    <else>
    public String getVisualizationJson() {
        throw new UnsupportedOperationException("Visualization support is disabled for this code." +
                "Re-run code generation with active visualization support to use this feature!");
    }
    <endif>
}
>>

tableBuilderSupplier(table) ::= <<
<if(table.explicitAttributes || table.notNullForeignKeys)>
/**
 * Adds a new entity of the type {@link <table.className>} to the RedG entities and returns it for further modification.
 *
 * \<table summary="The table model attributes and their values">
 *     \<tr>
 *         \<td>\<strong>Attribute\</strong>\</td>
 *         \<td>\<strong>Value\</strong>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Table name\</td>
 *         \<td><table.sqlName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Full table name\</td>
 *         \<td><table.sqlFullName>\</td>
 *     \</tr>
 * \</table>
 */
public <table.className> add<table.name>(<\\>
            <table.explicitAttributes:{it | Supplier\<<it.javaTypeName>\> <it.javaPropertyName>};separator=", "><\\>
            <if(table.explicitAttributes && table.notNullForeignKeys)>, <endif><table.notNullForeignKeys:{it | Supplier\<<it.javaTypeName>\> <it.javaPropertyName>};separator=", ">) {
    <table.className> obj = new <table.className>(true, this);
    this.entitySelfReference = obj;
    <table.explicitAttributes:{it | obj.<it.javaPropertyName>(<it.javaPropertyName>.get());};separator="\n">
    <table.notNullForeignKeys:{it | obj.<it.javaPropertyName>(<it.javaPropertyName>.get());};separator="\n">
    this.addEntity(obj);
    this.entitySelfReference = null;
    return obj;
}<\n>
<endif>
>>

tableBuilderExisting(table) ::= <<
/**
 * Creates a new reference to an existing entity of the type {@link <table.className>} in the database and returns it. Do not try to modify it or read
 * values other than the primary key(s).
 *
 * \<table summary="The table model attributes and their values">
 *     \<tr>
 *         \<td>\<strong>Attribute\</strong>\</td>
 *         \<td>\<strong>Value\</strong>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Table name\</td>
 *         \<td><table.sqlName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Full table name\</td>
 *         \<td><table.sqlFullName>\</td>
 *     \</tr>
 * \</table>
 */
<if(table.primaryKeyColumns)>
public <table.className> existing<table.name>(<table.primaryKeyColumns:{it|<it.javaTypeName> <it.javaPropertyName>};separator=", ">) {
    <table.className> obj = new Existing<table.className>(this<if(table.primaryKeyColumns)>, <endif><table.primaryKeyColumns:{it|<it.javaPropertyName>};separator=", ">);
    this.addEntity(obj);
    return obj;
}
<endif>
>>

tableBuilder(table) ::= <<
/**
 * Adds a new entity of the type {@link <table.className>} to the RedG entities and returns it for further modification.
 *
 * \<table summary="The table model attributes and their values">
 *     \<tr>
 *         \<td>\<strong>Attribute\</strong>\</td>
 *         \<td>\<strong>Value\</strong>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Table name\</td>
 *         \<td><table.sqlName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Full table name\</td>
 *         \<td><table.sqlFullName>\</td>
 *     \</tr>
 * \</table>
 */
public <table.className> add<table.name>(<\\>
            <table.explicitAttributes:{it | <it.javaTypeName> <it.javaPropertyName>};separator=", "><\\>
            <if(table.explicitAttributes && table.notNullForeignKeys)>, <endif><table.notNullForeignKeys:{it | <it.javaTypeName> <it.javaPropertyName>};separator=", ">) {
    <table.className> obj = new <table.className>(this<\\>
            <if(table.explicitAttributes)>, <endif><table.explicitAttributes:{it | <it.javaPropertyName>};separator=", "><\\>
            <if(table.notNullForeignKeys)>, <endif><table.notNullForeignKeys:{it | <it.javaPropertyName>};separator=", ">);
    this.addEntity(obj);
    return obj;
}<\n>
>>

tableBuilderDummy(table) ::= <<
/**
 * Adds a new dummy entity of the type {@link <table.className>} to the RedG entities and returns it. Modifying it might have unexpected results depending
 * on your dummy factory.
 *
 * \<table summary="The table model attributes and their values">
 *     \<tr>
 *         \<td>\<strong>Attribute\</strong>\</td>
 *         \<td>\<strong>Value\</strong>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Table name\</td>
 *         \<td><table.sqlName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Full table name\</td>
 *         \<td><table.sqlFullName>\</td>
 *     \</tr>
 * \</table>
 */
public <table.className> dummy<table.name>() {
    return this.getDummyFactory().getDummy(this, <table.className>.class);
}<\n>
>>

// ------------------------------- CLASS FOR EACH TABLE --------------------------------------------------------

tableClass(table, colAndForeignKeys, firstRowComma, secondRowComma, serializedTableModelString, enableVisualizationSupport) ::= <<
/*
 * This file was generated by RedG.
 * https://yamass.github.io/redg
 * DO NOT EDIT MANUALLY!
 * Re-run the code generation to reflect database changes.
 */
package <table.packageName>;

import java.util.ArrayList;
import java.util.List;

import de.yamass.redg.runtime.*;
import de.yamass.redg.models.*;

/**
 * \<table summary="The table model attributes and their values">
 *     \<tr>
 *         \<td>\<strong>Attribute\</strong>\</td>
 *         \<td>\<strong>Value\</strong>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Table name\</td>
 *         \<td><table.sqlName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Full table name\</td>
 *         \<td><table.sqlFullName>\</td>
 *     \</tr>
 * \</table>
 */
public class <table.className> implements RedGEntity {

    protected AbstractRedG redG;

    // do not manually make this public and instantiate it directly. Use the RedG Main class
    <table.className>(AbstractRedG redG<\\>
            <if(table.explicitAttributes)>, <endif><table.explicitAttributes:{it | <it.javaTypeName> <it.javaPropertyName>};separator=", "><\\>
            <if(table.notNullForeignKeys)>, <endif><table.notNullForeignKeys:{it | <it.javaTypeName> <it.javaPropertyName>};separator=", ">) {
        this.redG = redG;
        <table.explicitAttributes:{it | this.<it.javaPropertyName> = <it.javaPropertyName>;};separator="\n">
        <if(enableVisualizationSupport)><table.explicitAttributes:{it | this.modifiedFields.add("<it.javaPropertyName>");};separator="/n"><endif>
        <table.notNullForeignKeys:setWithNullCheck()>
        try {
            <table.nonExplicitNonFKAttributes:{it | this.<it.javaPropertyName> = redG.getDefaultValueStrategy().getDefaultValue(getTableModel().getColumnBySQLName("<escape.(it.dbName)>"), <it.javaTypeName>.class);<\n>}>
        } catch (Exception e) {
            throw new RuntimeException("Could not get default value", e);
        }
    }

    <if(table.explicitAttributes)>
    <table.className>(AbstractRedG redG<\\>
           <if(table.notNullForeignKeys)>, <endif><table.notNullForeignKeys:{it | <it.javaTypeName> <it.javaPropertyName>};separator=", ">) {
        // dummy constructor (without explicit attributes)
        this(
                redG,
                <table.explicitAttributes:{it | redG.getDefaultValueStrategy().getDefaultValue(getTableModel().getColumnBySQLName("<escape.(it.dbName)>"), <it.javaTypeName>.class)}; separator=",\n"><if(table.notNullForeignKeys)>,<endif>
                <table.notNullForeignKeys:{it | <it.javaPropertyName>};separator=",\n">
        );
    }
    <endif>

    <table.className>(boolean generateDefaultValues, AbstractRedG redG) {
        // First parameter exists simply because this constructor needs a different signature from the constructor above if the tables have no NOT NULL FK
        // Only for Existing<table.className> and usage with Supplier-Functions , otherwise NOT NULL constraints cannot be checked and no default values are generated.
        this.redG = redG;
        if (generateDefaultValues) {
            try {
                <table.nonExplicitNonFKAttributes:{it | this.<it.javaPropertyName> = redG.getDefaultValueStrategy().getDefaultValue(getTableModel().getColumnBySQLName("<escape.(it.dbName)>"), <it.javaTypeName>.class);<\n>}>
            } catch (Exception e) {
                throw new RuntimeException("Could not get default value", e);
            }
        }
    }

    <table.nonForeignKeyColumns:tableClassAttribute(table.className)>
    <table.nonForeignKeyColumns:convenienceSetters(table.className)>
    <table.nullableForeignKeys:tableClassAttribute(table.className)>
    <table.notNullForeignKeys:tableClassAttribute(table.className)>
    <table.nullableForeignKeys:rawForeignKeyGettersWithNullCheck()>
    <table.notNullForeignKeys:rawForeignKeyGetters()>
    <dependenciesGetter(table)>
    <table.incomingForeignKeys:incomingFKGetter()>
    <table.nullableIncomingForeignKeys:incomingFKAdd(table.className)>
    <joinTableSimplifier(table.joinTableSimplifierData)>

    public String getSQLString() {
        return String.format("INSERT INTO <escapeSql.(table.sqlName)> (" +
                        "<table.notNullForeignKeys:foreignKeyInsertColumns();separator=", ">" +
                        <if(table.notNullForeignKeys)><if(table.nullableForeignKeys)>", " +<endif><endif>
                        "<table.nullableForeignKeys:foreignKeyInsertColumns();separator=", ">" +
                        <if(colAndForeignKeys)>", " +<endif>
                        "<table.nonForeignKeyColumns:{c|<escapeSql.(c.dbName)>};separator=", ">" +
                        ") VALUES (" +
                        "<table.notNullForeignKeys:foreignKeyInsertPlaceholder();separator=", ">" +
                        <if(table.notNullForeignKeys)><if(table.nullableForeignKeys)>", " +<endif><endif>
                        "<table.nullableForeignKeys:foreignKeyInsertPlaceholder();separator=", ">" +
                        <if(colAndForeignKeys)>", " +<endif>
                        "<table.nonForeignKeyColumns:{c|%s};separator=", ">)",
                <table.notNullForeignKeys:foreignKeyInsertValues();separator=",\n"><if(firstRowComma)>,<endif>
                <table.nullableForeignKeys:foreignKeyInsertValuesNullable();separator=",\n"><if(secondRowComma)>,<endif>
                <table.nonForeignKeyColumns:columnInsertValues();separator=",\n">
        );
    }

    public String getPreparedStatementString() {
        return "INSERT INTO <escapeSql.(table.sqlName)> (" +
                "<table.notNullForeignKeys:foreignKeyInsertColumns();separator=", ">" +
                <if(table.notNullForeignKeys)><if(table.nullableForeignKeys)>", " +<endif><endif>
                "<table.nullableForeignKeys:foreignKeyInsertColumns();separator=", ">" +
                <if(colAndForeignKeys)>", " +<endif>
                "<table.nonForeignKeyColumns:{c|<escapeSql.(c.dbName)>};separator=", ">" +
                ") VALUES (" +
                "<table.notNullForeignKeys:foreignKeyInsertStmtPlaceholder();separator=", ">" +
                <if(table.notNullForeignKeys)><if(table.nullableForeignKeys)>", " +<endif><endif>
                "<table.nullableForeignKeys:foreignKeyInsertStmtPlaceholder();separator=", ">" +
                <if(colAndForeignKeys)>", " +<endif>
                "<table.nonForeignKeyColumns:{c|?};separator=", ">)";
    }

    public Object[] getPreparedStatementValues() {
        return new Object[]{
                <table.notNullForeignKeys:foreignKeyInsertStmtValues();separator=",\n"><if(firstRowComma)>,<endif>
                <table.nullableForeignKeys:foreignKeyInsertStmtValuesNullable();separator=",\n"><if(secondRowComma)>,<endif>
                <table.nonForeignKeyColumns:{c|this.<c.javaPropertyName>()};separator=",\n">
        };
    }

    public AttributeMetaInfo[] getPreparedStatementValuesMetaInfos() {
        return new AttributeMetaInfo[]{
                <table.notNullForeignKeys:foreignKeyInsertValueMetaInfos(true);separator=",\n"><if(firstRowComma)>,<endif>
                <table.nullableForeignKeys:foreignKeyInsertValueMetaInfos(false);separator=",\n"><if(secondRowComma)>,<endif>
                <table.nonForeignKeyColumns:columnInsertValueMetaInfo();separator=",\n">
        };
    }

    <if(serializedTableModelString)>
    private static String serializedTableModel = "<serializedTableModelString>";
    private static TableModel tableModel;

    public static String getSerializedTableModel() {
        return serializedTableModel;
    }

    public static TableModel getTableModel() {
        if (tableModel == null) {
            byte[] data = java.util.Base64.getDecoder().decode(serializedTableModel);
            try {
                java.io.ObjectInputStream ois = new java.io.ObjectInputStream(new java.io.ByteArrayInputStream(data));
                tableModel = (TableModel) ois.readObject();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return tableModel;
    }
    <endif>
    <if(enableVisualizationSupport)>
    private java.util.Set\<String> modifiedFields = new java.util.HashSet\<>();

    public java.util.Set\<String> getModifiedFields() {
        return this.modifiedFields;
    }
    <endif>
}
>>

incomingFKGetter(fk) ::= <<
<! TODO This implementation has very bad performance when a large amount of data is being modeled! Change this. !>
public List\<<fk.referencingJavaTypeName><">"> <fk.attributeName>() {
    return this.redG.findEntities(<fk.referencingJavaTypeName>.class, gEntity -> ((<fk.referencingJavaTypeName>) gEntity).<fk.referencingAttributeName>() == this);
}<\n>
>>

incomingFKAdd(fk, className) ::= <<
public <className> add<fk.attributeName; format="cap">(<fk.referencingJavaTypeName>... objects) {
    for (<fk.referencingJavaTypeName> obj : objects) {
        obj.<fk.referencingAttributeName>(this);
    }
    return this;
}<\n>
>>

joinTableSimplifier(joinTableData) ::= <<
<joinTableData.keys:{k|<singleJoinTableSimplifier(k, joinTableData.(k))>};separator="\n">
>>

singleJoinTableSimplifier(k, model) ::= <<
public <k> add<model.name>Relation(<model.methodParams.keys:{k|<k> <model.methodParams.(k)>};separator=", ">) {
    <k> rel = new <k>(this.redG<if(model.constructorParams)>, <endif><model.constructorParams:{p|<p>};separator=", ">);
    this.redG.addEntity(rel);
    return rel;
}
>>

setWithNullCheck(ref) ::= <<
if (<ref.javaPropertyName> == null) {
    throw new IllegalArgumentException("<ref.javaPropertyName> may not be null!");
}
this.<ref.javaPropertyName> = <ref.javaPropertyName>;<\n><\n>
>>

tableClassAttribute(column, className) ::= <<
private <column.javaTypeName> <column.javaPropertyName>;

/**
<if (column.dbName)>
 * \<table summary="The column model attributes and their values">
 *     \<tr>
 *         \<td>\<strong>Attribute\</strong>\</td>
 *         \<td>\<strong>Value\</strong>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Table name\</td>
 *         \<td><column.dbTableName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Full table name\</td>
 *         \<td><column.dbFullTableName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Column name\</td>
 *         \<td><column.dbName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>SQL type\</td>
 *         \<td><column.dbTypeName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Not nullable?\</td>
 *         \<td><column.notNull>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Part of Primary key?\</td>
 *         \<td><column.partOfPrimaryKey>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Unique?\</td>
 *         \<td><column.unique>\</td>
 *     \</tr>
 * \</table>
<else>
 * This is a foreign key referencing {@link <column.javaTypeName>}
<endif>
 */
public <className> <column.javaPropertyName>(<column.javaTypeName> value) {
    <if(column.notNull && !column.primitiveType)>
    if (value == null) {
        throw new IllegalArgumentException("Setting <column.javaPropertyName> to null violates a NOT NULL constraint!");
    }
    <endif>
    this.<column.javaPropertyName> = value;
    <if(enableVisualizationSupport)>this.modifiedFields.add("<column.javaPropertyName>");<endif>
    return this;
}

/**
<if (column.dbName)>
 * \<table summary="The column model attributes and their values">
 *     \<tr>
 *         \<td>\<strong>Attribute\</strong>\</td>
 *         \<td>\<strong>Value\</strong>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Table name\</td>
 *         \<td><column.dbTableName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Full table name\</td>
 *         \<td><column.dbFullTableName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Column name\</td>
 *         \<td><column.dbName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>SQL type\</td>
 *         \<td><column.dbTypeName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Not nullable?\</td>
 *         \<td><column.notNull>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Part of Primary key?\</td>
 *         \<td><column.partOfPrimaryKey>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Unique?\</td>
 *         \<td><column.unique>\</td>
 *     \</tr>
 * \</table>
<else>
 * This is a foreign key referencing {@link <column.javaTypeName>}
<endif>
 */
public <column.javaTypeName> <column.javaPropertyName>() {
    return this.<column.javaPropertyName>;
}
<\n>
>>

convenienceSetters(column, className) ::= <<
<column.convenienceSetters:convenienceSetter(column, className)>
>>

convenienceSetter(convenienceSetter, column, className) ::= <<
/**
<if (column.dbName)>
 * \<table summary="The column model attributes and their values">
 *     \<tr>
 *         \<td>\<strong>Attribute\</strong>\</td>
 *         \<td>\<strong>Value\</strong>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Table name\</td>
 *         \<td><column.dbTableName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Full table name\</td>
 *         \<td><column.dbFullTableName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Column name\</td>
 *         \<td><column.dbName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>SQL type\</td>
 *         \<td><column.dbTypeName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Not nullable?\</td>
 *         \<td><column.notNull>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Part of Primary key?\</td>
 *         \<td><column.partOfPrimaryKey>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Unique?\</td>
 *         \<td><column.unique>\</td>
 *     \</tr>
 * \</table>
<else>
 * This is a foreign key referencing {@link <column.javaTypeName>}
<endif>
 */
public <className> <column.javaPropertyName>(<convenienceSetter.setterJavaTypeName> value) {
    <if(column.notNull && !convenienceSetter.primitiveType)>
    if (value == null) {
        throw new IllegalArgumentException("Setting <column.javaPropertyName> to null violates a NOT NULL constraint!");
    }
    <endif>
    this.<column.javaPropertyName> = <convenienceSetter.fullyQualifiedConverterMethodName>(value, <column.javaTypeName>.class);
    <if(enableVisualizationSupport)>this.modifiedFields.add("<column.javaPropertyName>");<endif>
    return this;
}
<\n>
>>

foreignKeyInsertColumns(foreignKey) ::= <<
<foreignKey.references.keys:{k|<escapeSql.(k)>};separator=", ">
>>

foreignKeyInsertPlaceholder(foreignKey) ::= <<
<foreignKey.references.keys:{k|%s};separator=", ">
>>

foreignKeyInsertStmtPlaceholder(foreignKey) ::= <<
<foreignKey.references.keys:{k|?};separator=", ">
>>

foreignKeyInsertValues(foreignKey) ::= <<
<foreignKey.references.keys:{k|this.redG.getSqlValuesFormatter().formatValue(this.<foreignKey.javaPropertyName>.<foreignKey.references.(k).primaryKeyAttributeName>(),
        "<foreignKey.references.(k).dbTypeName>", "<escape.(foreignKey.references.(k).dbFullTableName)>",
        "<escape.(foreignKey.references.(k).dbTableName)>", "<escape.(foreignKey.references.(k).dbName)>")};separator=",\n">
>>

foreignKeyInsertValuesNullable(foreignKey) ::= <<
<foreignKey.references.keys:{k|this.redG.getSqlValuesFormatter().formatValue((this.<foreignKey.javaPropertyName> != null) ? this.<foreignKey.javaPropertyName>.<foreignKey.references.(k).primaryKeyAttributeName>() : null,
        "<foreignKey.references.(k).dbTypeName>", "<escape.(foreignKey.references.(k).dbFullTableName)>",
        "<escape.(foreignKey.references.(k).dbTableName)>", "<escape.(foreignKey.references.(k).dbName)>")};separator=",\n">
>>

foreignKeyInsertStmtValues(foreignKey) ::= <<
<foreignKey.references.keys:{k|this.<foreignKey.javaPropertyName>.<foreignKey.references.(k).primaryKeyAttributeName>()};separator=",\n">
>>

foreignKeyInsertStmtValuesNullable(foreignKey) ::= <<
<foreignKey.references.keys:{k|(this.<foreignKey.javaPropertyName> != null) ? this.<foreignKey.javaPropertyName>.<foreignKey.references.(k).primaryKeyAttributeName>() : null};separator=",\n">
>>

foreignKeyInsertValueMetaInfos(foreignKey, notNull) ::= <<
<foreignKey.references.keys:{k|new AttributeMetaInfo("<escape.(foreignKey.references.(k).dbName)>", "<escape.(foreignKey.references.(k).dbTableName)>", "<escape.(foreignKey.references.(k).dbFullTableName)>", "<escape.(foreignKey.references.(k).dbTypeName)>", <foreignKey.references.(k).sqlTypeInt>, <foreignKey.references.(k).localType>.class, <notNull>)};separator=",\n">
>>

columnInsertValueMetaInfo(column) ::= <<
new AttributeMetaInfo("<escape.(column.dbName)>", "<escape.(column.dbTableName)>", "<escape.(column.dbFullTableName)>", "<escape.(column.dbTypeName)>", <column.sqlTypeInt>, <column.javaTypeName>.class, <column.notNull>)
>>

columnInsertValues(column) ::= <<
this.redG.getSqlValuesFormatter().formatValue(this.<column.javaPropertyName>(),
        "<escape.(column.dbTypeName)>", "<escape.(column.dbFullTableName)>",
        "<escape.(column.dbTableName)>", "<escape.(column.dbName)>")
>>

rawForeignKeyGetters(fKey) ::= <<
<fKey.references.keys:{k|<rawForeignKeyGetter(fKey.references.(k), fKey.javaPropertyName)>}>
>>

rawForeignKeyGettersWithNullCheck(fKey) ::= <<
<fKey.references.keys:{k|<rawForeignKeyGetterWithNullCheck(fKey.references.(k), fKey.javaPropertyName)>}>
>>

dependenciesGetter(table) ::= <<
public List\<RedGEntity> getDependencies() {
    List\<RedGEntity> dependencies = new ArrayList\<>();
    <table.foreignKeys:{fk|if (<fk.javaPropertyName> != null) dependencies.add(<fk.javaPropertyName>);};separator="\n">
    return dependencies;
}<\n>
>>

rawForeignKeyGetter(ref, varName) ::= <<
/**
 * \<table summary="The column model attributes and their values">
 *     \<tr>
 *         \<td>\<strong>Attribute\</strong>\</td>
 *         \<td>\<strong>Value\</strong>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Table name\</td>
 *         \<td><ref.dbTableName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Full table name\</td>
 *         \<td><ref.dbFullTableName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>Column name\</td>
 *         \<td><ref.dbName>\</td>
 *     \</tr>
 *     \<tr>
 *         \<td>SQL type\</td>
 *         \<td><ref.dbTypeName>\</td>
 *     \</tr>
 * \</table>
 */
public <ref.localType> <ref.localName>() {
    return this.<varName>.<ref.primaryKeyAttributeName>();
}<\n>
>>

rawForeignKeyGetterWithNullCheck(ref, varName) ::= <<
public <ref.localType> <ref.localName>() {
    if (this.<varName> != null) {
        return this.<varName>.<ref.primaryKeyAttributeName>();
    }
    return null;
}<\n>
>>

// ------------------------------- CLASS FOR EACH TABLE (EXISTING ENTRIES) --------------------------------------------------------

existingTableClass(table) ::= <<
/*
 * This file was generated by RedG.
 * https://yamass.github.io/redg
 * DO NOT EDIT MANUALLY!
 * Re-run the code generation to reflect database changes.
 */
package <table.packageName>;

import de.yamass.redg.runtime.*;

/**
 * {@inheritDoc}
 */
public class Existing<table.className> extends <table.className> {

    Existing<table.className>(AbstractRedG redG<if(table.primaryKeyColumns)>, <endif><table.primaryKeyColumns:{it|<it.javaTypeName> <it.javaPropertyName>};separator=", ">) {
        super(false, redG);
        <if (table.primaryKeyColumns)>
        <table.primaryKeyColumns:{it|<if(it.partOfForeignKey)>this.<it.javaPropertyName> = <it.javaPropertyName><else>super.<it.javaPropertyName>(<it.javaPropertyName>)<endif>};separator=";\n">;
        <else>
        throw new UnsupportedOperationException("Cannot reference an existing entity if the table has no primary keys");
        <endif>
    }

    <table.primaryKeyColumns:overrideTableClassAttributesPK(table.className)>
    <table.nonPrimaryKeyNonFKColumns:overrideTableClassAttributes(table.className)>
    <table.nonForeignKeyColumns:overrideConvenienceSetters(table.className)>
    <table.foreignKeys:overrideTableClassAttributes(table.className)>
    <table.foreignKeys:overrideRawForeignKeyGetters()>

    @Override
    public String getSQLString() {
    <if (table.primaryKeyColumns)>
        return String.format("SELECT COUNT(*) FROM <escapeSql.(table.sqlName)> WHERE " +
                        "<table.primaryKeyColumns:{it|<escapeSql.(it.dbName)> = %s};separator=" AND ">",
                <table.primaryKeyColumns:overrideColumnInsertValues();separator=",\n">
        );
    <else>
        return "Your table has no primary key(s), referincing existing entities is not possible!";
    <endif>
    }

    @Override
    public String getPreparedStatementString() {
    <if (table.primaryKeyColumns)>
        return "SELECT COUNT(*) FROM <escapeSql.(table.sqlName)> WHERE " +
                <table.primaryKeyColumns:{it|"<escapeSql.(it.dbName)> = ?};separator=" AND \" +\n">";
    <else>
        return "Your table has no primary key(s), referencing existing entities is not possible!";
    <endif>
    }

    @Override
    public Object[] getPreparedStatementValues() {
        return new Object[] {
                <table.primaryKeyColumns:{c|<if(c.partOfForeignKey)>this.<c.javaPropertyName><else>super.<c.javaPropertyName>()<endif>};separator=",\n">
        };
    }

    @Override
    public AttributeMetaInfo[] getPreparedStatementValuesMetaInfos() {
        return new AttributeMetaInfo[] {
                <table.primaryKeyColumns:columnInsertValueMetaInfo();separator=",\n">
        };
    }
}
>>

overrideTableClassAttributes(column, className) ::= <<
/**
 * {@inheritDoc}
 */
@Override
public <className> <column.javaPropertyName>(<column.javaTypeName> value) {
    throw new UnsupportedOperationException("Cannot change values of entities declared as existing.");
}

/**
 * {@inheritDoc}
 */
@Override
public <column.javaTypeName> <column.javaPropertyName>() {
    throw new UnsupportedOperationException("Cannot read values of entities declared as existing that are not part of the primary key.");
}
<\n>
>>

overrideConvenienceSetters(column, className) ::= <<
<column.convenienceSetters:overrideConvenienceSetter(column, className)>
>>

overrideConvenienceSetter(convenienceSetter, column, className) ::= <<
/**
 * {@inheritDoc}
 */
@Override
public <className> <column.javaPropertyName>(<convenienceSetter.setterJavaTypeName> value) {
    throw new UnsupportedOperationException("Cannot change values of entities declared as existing.");
}
<\n>

>>

overrideTableClassAttributesPK(column, className) ::= <<
<if(!column.partOfForeignKey)>/**
 * {@inheritDoc}
 */
@Override
public <className> <column.javaPropertyName>(<column.javaTypeName> value) {
    throw new UnsupportedOperationException("Cannot change values of entities declared as existing.");
}

/**
 * {@inheritDoc}
 */
@Override
public <column.javaTypeName> <column.javaPropertyName>() {
    return super.<column.javaPropertyName>();
}
<\n><else>
// This is an attribute for a primary key that is a foreign key as well
private <column.javaTypeName> <column.javaPropertyName>;
<endif>
>>

overrideRawForeignKeyGetters(fKey) ::= <<
<fKey.references.keys:{k|<overrideRawForeignKeyGetter(fKey.references.(k), fKey.javaPropertyName)>}>
>>

overrideRawForeignKeyGetter(ref, varName) ::= <<
@Override
public <ref.localType> <ref.localName>() {
    throw new UnsupportedOperationException("Cannot read values of entities declared as existing that are not part of the primary key.");
}<\n>
>>

overrideColumnInsertValues(column) ::= <<
this.redG.getSqlValuesFormatter().formatValue(<if(column.partOfForeignKey)>this.<column.javaPropertyName><else>super.<column.javaPropertyName>()<endif>,
        "<column.dbTypeName>", "<escape.(column.dbTableName)>",
        "<escape.(column.dbTableName)>", "<escape.(column.dbName)>")
>>

enum(dataType, packageName) ::= <<
/*
 * This file was generated by RedG.
 * https://yamass.github.io/redg
 * DO NOT EDIT MANUALLY!
 * Re-run the code generation to reflect database changes.
 */
package <packageName>;

import java.util.ArrayList;
import java.util.List;

import de.yamass.redg.runtime.*;
import de.yamass.redg.models.*;

/**
 * <dataType.name>
 */
public enum <dataType.name> {
    <dataType.enumValues:{v|<v>("<v>")};separator=",\n">;

    String literal;

    public <dataType.name>(String literal) {
        this.literal = literal;
    }
}
>>
